#!/usr/bin/env ruby

class Board
  ROWS = 6
  COLS = 7
  attr_reader :grid

  def initialize
    @grid = Array.new(ROWS) { Array.new(COLS, '·') }
    @row_index = Array.new(COLS, ROWS - 1)
  end

  def draw
    system('clear') || system('cls')
    puts " [Connect Four]"
    puts "================"
    
    print "  "
    (1..COLS).each { |col| print "#{col} " }
    puts
    
    ROWS.times do |i|
      row = @grid[i]
      print "#{ROWS - i}|"
      row.each { |cell| print "#{cell}|" }
      puts
    end
    
    print " +"
    (1..COLS).each { print "-+" }
    puts
    
    print "  "
    (1..COLS).each { |col| print "#{col} " }
    puts
    
    puts
  end

  def drop_piece(col, disc)
    col -= 1  # 0始まりに変換
    if col < 0 || col >= @row_index.length
      return false
    end
    
    if @row_index[col] >= 0
      @grid[@row_index[col]][col] = disc
      @row_index[col] -= 1
      return true
    else
      return false  # 列が満杯
    end
  end

  def check_win(disc)
    # 横
    @grid.each do |row|
      row.each_cons(4) do |cells|
        return true if cells.all?(disc)
      end
    end

    # 縦
    (0...COLS).each do |c|
      (0...ROWS - 3).each do |r|
        return true if (0..3).all? { |k| @grid[r + k][c] == disc }
      end
    end

    # 斜め (右下がり)
    (0...ROWS - 3).each do |r|
      (0...COLS - 3).each do |c|
        return true if (0..3).all? { |k| @grid[r + k][c + k] == disc }
      end
    end

    # 斜め (左下がり)
    (3...ROWS).each do |r|
      (0...COLS - 3).each do |c|
        return true if (0..3).all? { |k| @grid[r - k][c + k] == disc }
      end
    end

    false
  end

  def available_cols
    (1..COLS).select { |c| @row_index[c-1] >= 0 }
  end

  def valid_col?(col)
    col >= 1 && col <= COLS
  end

  def unplace_piece(col)
    col -= 1
    return if col < 0 || col >= @row_index.length
    
    # 直前に置かれた駒の位置を特定
    r = @row_index[col] + 1
    if r < ROWS
      @grid[r][col] = '·'
      @row_index[col] += 1
    end
  end

  def deep_copy
    new_board = Board.new
    new_board.instance_variable_set(:@grid, @grid.map(&:dup))
    new_board.instance_variable_set(:@row_index, @row_index.dup)
    new_board
  end

  def grid_empty?
    @grid.all? { |row| row.all?('·') }
  end
end

class Player
  attr_reader :disc, :name

  def initialize(disc, name)
    @disc = disc
    @name = name
  end

  def get_move(board)
    raise NotImplementedError
  end
end

class HumanPlayer < Player
  def get_move(board)
    print "#{@name}の手番です。列を選択してください (1-#{Board::COLS})、終了する場合は'!': "
    input = $stdin.gets.chomp
    return :quit if input == '!'
    input.to_i
  end
end

class RandomPlayer < Player
  def get_move(board)
    available = board.available_cols
    return :draw if available.empty?
    available.sample
  end
end


class NaivePlayer < Player
  def get_move(board)
    # 先手（盤面が空）のときはあきらかに有利な中央（カラム4）に打つ
    return 4 if board.grid_empty?

    available = board.available_cols
    return :draw if available.empty?

    opponent_disc = (@disc == '●') ? '○' : '●'

    # 自分が次に勝てる手があるかチェックし、あれば打つ
    available.each do |col|
      if board.drop_piece(col, @disc)
        if board.check_win(@disc)
          board.unplace_piece(col)
          return col
        end
        board.unplace_piece(col)
      end
    end

    # 相手が次に勝つ手があるかチェックし、あれば防ぐ
    available.each do |col|
      if board.drop_piece(col, opponent_disc)
        if board.check_win(opponent_disc)
          board.unplace_piece(col)
          return col
        end
        board.unplace_piece(col)
      end
    end

    available.sample
  end
end

class IntermediatePlayer < Player
  def get_move(board)
    # 先手（盤面が空）のときはあきらかに有利な中央（カラム4）に打つ
    return 4 if board.grid_empty?

    available = board.available_cols
    return :draw if available.empty?

    best_score = -Float::INFINITY
    best_cols = []

    # 3手読み (自分 -> 相手 -> 自分)
    available.each do |col|
      board.drop_piece(col, @disc)
      # 残り深さ2 (相手 -> 自分)
      score = minimax(board, 2, false)
      board.unplace_piece(col)

      if score > best_score
        best_score = score
        best_cols = [col]
      elsif score == best_score
        best_cols << col
      end
    end

    best_cols.sample
  end

  def minimax(board, depth, is_maximizing)
    opponent_disc = (@disc == '●') ? '○' : '●'

    if board.check_win(@disc)
      return 100 + depth
    elsif board.check_win(opponent_disc)
      return -100 - depth
    end

    return 0 if depth == 0 || board.available_cols.empty?

    if is_maximizing
      scores = board.available_cols.map do |col|
        board.drop_piece(col, @disc)
        score = minimax(board, depth - 1, false)
        board.unplace_piece(col)
        score
      end
      scores.max
    else
      scores = board.available_cols.map do |col|
        board.drop_piece(col, opponent_disc)
        score = minimax(board, depth - 1, true)
        board.unplace_piece(col)
        score
      end
      scores.min
    end
  end
end

class AdvancedPlayer < Player
  def initialize(disc, name, depth = 5)
    super(disc, name)
    @depth = depth
  end

  def get_move(board)
    # 先手（盤面が空）のときはあきらかに有利な中央（カラム4）に打つ
    return 4 if board.grid_empty?

    available = board.available_cols
    return :draw if available.empty?

    best_score = -Float::INFINITY
    best_cols = []

    alpha = -Float::INFINITY
    beta = Float::INFINITY

    available.each do |col|
      board.drop_piece(col, @disc)
      score = alpha_beta(board, @depth - 1, alpha, beta, false)
      board.unplace_piece(col)

      if score > best_score
        best_score = score
        best_cols = [col]
      elsif score == best_score
        best_cols << col
      end
      alpha = [alpha, score].max
    end

    best_cols.sample
  end

  def alpha_beta(board, depth, alpha, beta, is_maximizing)
    opponent_disc = (@disc == '●') ? '○' : '●'

    if board.check_win(@disc) then return 100000 + depth end
    if board.check_win(opponent_disc) then return -100000 - depth end
    return score_board(board, @disc) if depth == 0 || board.available_cols.empty?

    if is_maximizing
      max_eval = -Float::INFINITY
      board.available_cols.each do |col|
        board.drop_piece(col, @disc)
        eval = alpha_beta(board, depth - 1, alpha, beta, false)
        board.unplace_piece(col)
        max_eval = [max_eval, eval].max
        alpha = [alpha, eval].max
        break if beta <= alpha
      end
      max_eval
    else # minimizing
      min_eval = Float::INFINITY
      board.available_cols.each do |col|
        board.drop_piece(col, opponent_disc)
        eval = alpha_beta(board, depth - 1, alpha, beta, true)
        board.unplace_piece(col)
        min_eval = [min_eval, eval].min
        beta = [beta, eval].min
        break if beta <= alpha
      end
      min_eval
    end
  end

  def score_board(board, piece)
    score = 0
    opp_piece = (piece == '●') ? '○' : '●'
    
    # 中央列の評価
    center_col = Board::COLS / 2
    center_count = board.grid.map { |r| r[center_col] }.count(piece)
    score += center_count * 3

    # 横方向
    board.grid.each do |row|
      row.each_cons(4) { |w| score += evaluate_window(w, piece, opp_piece) }
    end

    # 縦方向
    (0...Board::COLS).each do |c|
      col_array = (0...Board::ROWS).map { |r| board.grid[r][c] }
      col_array.each_cons(4) { |w| score += evaluate_window(w, piece, opp_piece) }
    end

    # 斜め (右下がり)
    (0...Board::ROWS - 3).each do |r|
      (0...Board::COLS - 3).each do |c|
        window = (0..3).map { |k| board.grid[r + k][c + k] }
        score += evaluate_window(window, piece, opp_piece)
      end
    end

    # 斜め (左下がり)
    (3...Board::ROWS).each do |r|
      (0...Board::COLS - 3).each do |c|
        window = (0..3).map { |k| board.grid[r - k][c + k] }
        score += evaluate_window(window, piece, opp_piece)
      end
    end

    score
  end

  def evaluate_window(window, piece, opp_piece)
    score = 0
    if window.count(piece) == 3 && window.count('·') == 1
      score += 10
    elsif window.count(piece) == 2 && window.count('·') == 2
      score += 2
    end

    if window.count(opp_piece) == 3 && window.count('·') == 1
      score -= 8
    elsif window.count(opp_piece) == 2 && window.count('·') == 2
      score -= 1
    end
    
    score
  end
end

class MCTSNode
  attr_accessor :move, :parent, :children, :wins, :visits, :untried_moves, :player_just_moved

  def initialize(move, parent, available_moves, player_just_moved)
    @move = move
    @parent = parent
    @children = []
    @wins = 0.0
    @visits = 0
    @untried_moves = available_moves
    @player_just_moved = player_just_moved
  end

  def select_child
    @children.max_by do |child|
      child.wins / child.visits.to_f + Math.sqrt(2 * Math.log(@visits) / child.visits.to_f)
    end
  end

  def add_child(move, available_moves, player_just_moved)
    child = MCTSNode.new(move, self, available_moves, player_just_moved)
    @children << child
    child
  end
end

class ExpertPlayer < Player
  def initialize(disc, name, iterations = 1000)
    super(disc, name)
    @iterations = iterations
  end

  def get_move(board)
    available = board.available_cols
    return :draw if available.empty?

    return 4 if board.grid_empty?

    root = MCTSNode.new(nil, nil, available, nil)
    
    @iterations.times do
      node = root
      temp_board = board.deep_copy
      current_player = @disc

      # 1. Selection
      while node.untried_moves.empty? && !node.children.empty?
        node = node.select_child
        temp_board.drop_piece(node.move, current_player)
        current_player = (current_player == '●' ? '○' : '●')
      end

      # 2. Expansion
      if !node.untried_moves.empty?
        move = node.untried_moves.sample
        node.untried_moves.delete(move)
        temp_board.drop_piece(move, current_player)
        node = node.add_child(move, temp_board.available_cols, current_player)
        current_player = (current_player == '●' ? '○' : '●')
      end

      # 3. Simulation
      sim_player = current_player
      winner = nil
      last_mover = (sim_player == '●' ? '○' : '●')
      
      if temp_board.check_win(last_mover)
        winner = last_mover
      else
        loop do
          available = temp_board.available_cols
          break if available.empty?
          move = available.sample
          temp_board.drop_piece(move, sim_player)
          if temp_board.check_win(sim_player)
            winner = sim_player
            break
          end
          sim_player = (sim_player == '●' ? '○' : '●')
        end
      end

      # 4. Backpropagation
      while node
        node.visits += 1
        if node.player_just_moved
          if winner == node.player_just_moved
            node.wins += 1
          elsif winner == nil
            node.wins += 0.5
          end
        end
        node = node.parent
      end
    end

    return board.available_cols.sample if root.children.empty?
    root.children.max_by(&:visits).move
  end
end

class ConnectFour
  def initialize(player1, player2, wait_time = 1, display = true)
    @board = Board.new
    @players = [player1, player2]
    @current_player_idx = 0
    @wait_time = wait_time
    @display = display
  end

  def current_player
    @players[@current_player_idx]
  end

  def switch_player
    @current_player_idx = (@current_player_idx + 1) % @players.size
  end

  def play
    loop do
      @board.draw if @display
      
      move = current_player.get_move(@board)
      
      if move == :quit
        puts "ゲームを終了します。" if @display
        return :quit
      elsif move == :draw
        puts "引き分けです！" if @display
        return :draw
      end
      
      col = move

      # バリデーション (人間の場合)
      if current_player.is_a?(HumanPlayer) && !@board.valid_col?(col)
        if @display
          puts "1から#{Board::COLS}の範囲で入力してください。"
          sleep(@wait_time)
        end
        next
      end

      if @board.drop_piece(col, current_player.disc)
        if @board.check_win(current_player.disc)
          if @display
            @board.draw
            unless current_player.is_a?(HumanPlayer)
              puts "#{current_player.name} が列 #{col} に手を指しました。"
            end
            puts "#{current_player.name} の勝ちです！"
          end
          return current_player
        end
        
        if @display
          unless current_player.is_a?(HumanPlayer)
            puts "#{current_player.name} が列 #{col} に手を指しました。"
            sleep(@wait_time)
          end
        end
        
        switch_player
      else
        if @display
          puts "その列は満杯です。別の列を選んでください。"
          sleep(@wait_time) if current_player.is_a?(HumanPlayer)
        end
      end
    end
  end
end

def create_player(type, disc, name)
  t = type.to_s.downcase
  if t =~ /^a(?:dvanced)?(\d+)?$/
    depth = $1 ? $1.to_i : 5
    return AdvancedPlayer.new(disc, name, depth)
  end
  if t =~ /^e(?:xpert)?(\d+)?$/
    iter = $1 ? $1.to_i : 1000
    return ExpertPlayer.new(disc, name, iter)
  end

  case t
  when 'human', 'h' then HumanPlayer.new(disc, name)
  when 'random', 'r' then RandomPlayer.new(disc, name)
  when 'naive', 'n' then NaivePlayer.new(disc, name)
  when 'intermediate', 'i' then IntermediatePlayer.new(disc, name)
  when 'expert', 'e' then ExpertPlayer.new(disc, name)
  else NaivePlayer.new(disc, name)
  end
end

def get_full_type_name(type)
  t = type.to_s.downcase
  if t =~ /^a(?:dvanced)?(\d+)?$/
    depth = $1 ? $1.to_i : 5
    return "Advanced(#{depth})"
  end
  if t =~ /^e(?:xpert)?(\d+)?$/
    iter = $1 ? $1.to_i : 1000
    return "Expert(#{iter})"
  end

  case t
  when 'human', 'h' then 'Human'
  when 'random', 'r' then 'Random'
  when 'naive', 'n' then 'Naive'
  when 'intermediate', 'i' then 'Intermediate'
  when 'expert', 'e' then 'Expert'
  else 'Naive'
  end
end

def run_single_match(i, p1_type, p2_type, wait_time, display_mode)
  p1_desc = get_full_type_name(p1_type)
  p2_desc = get_full_type_name(p2_type)

  if i.even?
    player_a = create_player(p1_type, '●', "Player 1 (#{p1_desc})")
    player_b = create_player(p2_type, '○', "Player 2 (#{p2_desc})")
    game = ConnectFour.new(player_a, player_b, wait_time, display_mode)
    p1_obj = player_a
    p2_obj = player_b
  else
    player_a = create_player(p2_type, '●', "Player 2 (#{p2_desc})")
    player_b = create_player(p1_type, '○', "Player 1 (#{p1_desc})")
    game = ConnectFour.new(player_a, player_b, wait_time, display_mode)
    p1_obj = player_b
    p2_obj = player_a
  end

  if display_mode
    puts "=== 第 #{i + 1} 戦 ==="
  end

  result = game.play
  
  if result == :quit
    return :quit
  elsif result == :draw
    return :draw
  elsif result == p1_obj
    return :p1
  elsif result == p2_obj
    return :p2
  end
  :draw
end

# 引数解析
args = ARGV.dup

# -d オプション (描画なし)
d_index = args.index('-d')
display_mode = true
if d_index
  display_mode = false
  args.slice!(d_index)
end

# -j オプション (並列数)
j_arg_index = args.find_index { |arg| arg.start_with?('-j') }
jobs = 1
if j_arg_index
  val = args[j_arg_index][2..-1].to_i
  jobs = val > 0 ? val : 32
  args.slice!(j_arg_index)
end

match_count = 1
c_arg_index = args.find_index { |arg| arg.start_with?('-c') }
if c_arg_index
  val = args[c_arg_index][2..-1].to_i
  match_count = val if val > 0
  args.slice!(c_arg_index)
end

p1_type = args[0] || 'human'
p2_type = args[1] || 'naive'
wait_time = display_mode ? (match_count > 1 ? 0.5 : 1) : 0

results = { p1: 0, p2: 0, draw: 0 }

if jobs > 1 && match_count > 1
  # 並列実行モード
  puts "Running #{match_count} matches with #{jobs} parallel jobs..."
  
  quotient, remainder = match_count.divmod(jobs)
  pipes = []

  jobs.times do |j|
    count = quotient + (j < remainder ? 1 : 0)
    next if count == 0

    r, w = IO.pipe
    pipes << r

    fork do
      r.close
      srand # 乱数シード再初期化
      
      local_results = { p1: 0, p2: 0, draw: 0 }
      
      # 開始インデックスの計算
      start_index = 0
      (0...j).each { |prev_j| start_index += quotient + (prev_j < remainder ? 1 : 0) }

      count.times do |k|
        res = run_single_match(start_index + k, p1_type, p2_type, 0, false)
        local_results[res] += 1 if res != :quit
      end

      Marshal.dump(local_results, w)
      w.close
      exit
    end
    w.close
  end

  pipes.each do |r|
    local_res = Marshal.load(r)
    results[:p1] += local_res[:p1]
    results[:p2] += local_res[:p2]
    results[:draw] += local_res[:draw]
    r.close
  end
  
  Process.waitall
else
  # 通常実行モード
  match_count.times do |i|
    unless display_mode
      print "\rProgress: #{i + 1}/#{match_count}"
    end

    res = run_single_match(i, p1_type, p2_type, wait_time, display_mode)
    break if res == :quit
    results[res] += 1
    
    if display_mode && match_count > 1
      puts "--------------------------------"
      puts "途中経過 (#{i + 1}/#{match_count}戦):"
      puts "Player 1 (#{get_full_type_name(p1_type)}): #{results[:p1]}勝"
      puts "Player 2 (#{get_full_type_name(p2_type)}): #{results[:p2]}勝"
      puts "引き分け: #{results[:draw]}"
      puts "--------------------------------"
      sleep(3)
    elsif display_mode
      sleep(wait_time)
    end
  end
end
puts unless display_mode

puts "\n=== 通算結果 (#{match_count}戦) ==="
puts "Player 1 (#{get_full_type_name(p1_type)}): #{results[:p1]}勝"
puts "Player 2 (#{get_full_type_name(p2_type)}): #{results[:p2]}勝"
puts "引き分け: #{results[:draw]}"
